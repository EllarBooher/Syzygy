#version 460
#extension GL_EXT_debug_printf : enable
//size of a workgroup for compute
layout (local_size_x = 16, local_size_y = 16) in;
layout(rgba16f,set = 0, binding = 0) uniform image2D image;

layout( push_constant ) uniform Camera
{
	mat4 inverseProjection;
	mat4 rotation;
	vec3 cameraPosition;
} camera;

bool raySphereIntersection(dvec3 rayOrigin, dvec3 rayDirectionNormalized, double radius, out double t0, out double t1)
{
	/*
	* Method taken from "Precision Improvements for Ray/Sphere Intersection"
	* by Eric Haines, Johannes Günther, and Tomas Akenine-Möller
	*
	* The method includes tricks to reduce float point inaccuracy errors.
	*/

	const dvec3 f = rayOrigin;
	const dvec3 d = rayDirectionNormalized;
	const double b = -1.0 * dot(f, d);
	const dvec3 centerToIntersectionChord = f + b * d;
	const double discriminant = radius * radius - dot(centerToIntersectionChord, centerToIntersectionChord);
	const double c = dot(f, f) - radius * radius;

	if (discriminant < 0.0)
	{
		return false;
	}

	double q = b;
	if (b < 0.0)
	{
		q -= sqrt(discriminant);
	}
	else
	{
		q += sqrt(discriminant);
	}

	t0 = c / q;
	t1 = q;

	if (t0 > t1)
	{
		const double temp = t0;
		t0 = t1;
		t1 = temp;
	}

	return true;
}

double computePhase(double reflectionCosine, double anisotropy)
{
	const double pi = 3.141592653589793;

	return 3.0 / (8.0 * pi) 
		* ((1.0 - anisotropy * anisotropy) * (1.0 + reflectionCosine * reflectionCosine)) 
		/ ((2.0 + reflectionCosine * reflectionCosine) * pow(float(1.0 + anisotropy * anisotropy - 2.0 * reflectionCosine * anisotropy), 1.5));
}

dvec3 computeAtmosphereLight(dvec3 origin, dvec3 direction)
{
	/*
	* Constants and implementation derived from:
	* https://www.scratchapixel.com/lessons/procedural-generation-virtual-worlds/simulating-sky/simulating-colors-of-the-sky.html
	* Which is based on the original paper "Display of the Earth Taking into Account Atmospheric Scattering"
	* by Tomoyuki Nishita, Takao Sirai, Katsumi Tadamura, Eihachiro Nakamae
	*/ 

	const double earthRadiusMeters = 6378000;
	const double atmosphereRadiusMeters = 6420000;

	origin -= dvec3(0.0, earthRadiusMeters, 0.0);

	const dvec3 directionToSun = normalize(dvec3(0.0,-1.0,0.0));
	const double pi = 3.141592653589793;
	const double altitudeDecayRayleigh = 7994.0;
	const double altitudeDecayMie = 1200.0;
	const dvec3 scatteringCoefficientRayleigh = dvec3(0.0000038,0.0000135, 0.0000331);
	const dvec3 scatteringCoefficientMie = dvec3(0.000021);
	
	// Assume slight blue tint to fake secondary bounces from sky
	const dvec3 groundColor = dvec3(0.80, 0.80, 0.90);

	double t0, t1;
	const bool viewingAtmosphere = raySphereIntersection(origin, direction, atmosphereRadiusMeters, t0, t1);

	if (!viewingAtmosphere || t1 < 0.0)
	{
		return dvec3(0.0);
	}

	double t0Earth, t1Earth;
	const bool hittingEarth = raySphereIntersection(origin, direction, earthRadiusMeters, t0Earth, t1Earth);

	if (hittingEarth && t1Earth >= 0.0)
	{
		// We early return to save performance since these rays don't see much contribution by scattering
		return groundColor;
	}

	const double tSampleStart = max(t0, 0.0); // Only sample forward from the origin
	const double tSampleEnd = t1;

	dvec3 contributionRayleigh = dvec3(0.0);
	dvec3 contributionMie = dvec3(0.0);

	double opticalDepthRayleigh = 0;
	double opticalDepthMie = 0;

	const double cosineSun = dot(direction, directionToSun);

	const double phaseRayleigh = computePhase(cosineSun, 0.0);
	const double phaseMie = computePhase(cosineSun, 0.76);

	const uint sampleCount = 8;
	const double segmentLength = (tSampleEnd - tSampleStart) / sampleCount;
	for(uint i = 0; i < sampleCount; i++)
	{
		// We sample the middle of each segment

		const dvec3 samplePosition = origin + ((double(i) + 0.5lf) * segmentLength + tSampleStart) * direction;

		const double altitude = length(samplePosition) - earthRadiusMeters;

		// These measure the optical depth or "density" of particles contributing to rayleigh/mie scattering
		// The crux of this method is to integrate 
		const double depthRayleigh = exp(float(-altitude / altitudeDecayRayleigh)) * segmentLength;
		const double depthMie = exp(float(-altitude / altitudeDecayMie)) * segmentLength;

		opticalDepthRayleigh += depthRayleigh;
		opticalDepthMie += depthMie;

		double t0Light, t1Light;
		raySphereIntersection(samplePosition, directionToSun, atmosphereRadiusMeters, t0Light, t1Light);

		const uint sampleCountLight = 2;
		const double segmentLengthLight = (t1Light - 0.0) / double(sampleCountLight);
		double opticalDepthLightRayleigh = 0.0;
		double opticalDepthLightMie = 0.0;
		for (uint j = 0; j < sampleCountLight; j++)
		{
			const dvec3 samplePositionLight = samplePosition + (double(j) + 0.5) * segmentLengthLight * directionToSun;
	
			const double altitudeLight = length(samplePositionLight) - earthRadiusMeters;
			if (altitudeLight < 0.0)
			{
				break;
			}
			opticalDepthLightRayleigh += exp(float(-altitudeLight / altitudeDecayRayleigh)) * segmentLengthLight;
			opticalDepthLightMie += exp(float(-altitudeLight / altitudeDecayMie)) * segmentLengthLight;

			// This light ray is only contributed when it never intersects the ground
			// We ignore secondary contributions
			if (j == sampleCountLight - 1)
			{
				const dvec3 tau = scatteringCoefficientRayleigh * (opticalDepthRayleigh + opticalDepthLightRayleigh)
							   + scatteringCoefficientMie * 1.1f * (opticalDepthMie + opticalDepthLightMie);

				const dvec3 attenuation = dvec3(exp(float(-tau.x)),exp(float(-tau.y)),exp(float(-tau.z)));

				contributionRayleigh += attenuation * depthRayleigh;
				contributionMie += attenuation * depthMie;
			}
		}
	}

	dvec3 color =(contributionRayleigh * scatteringCoefficientRayleigh * phaseRayleigh + contributionMie * scatteringCoefficientMie * phaseMie) * 20.0;

	// Compute transmittance to include ground color
	if (hittingEarth && t1Earth >= 0.0)
	{
		const dvec3 tau = scatteringCoefficientRayleigh * opticalDepthRayleigh
					+ scatteringCoefficientMie * 1.1f * opticalDepthMie;

		const dvec3 attenuation = dvec3(exp(float(-tau.x)),exp(float(-tau.y)),exp(float(-tau.z)));



		color += attenuation * groundColor;
	}

	return color;
}

void main() 
{
	vec2 size = imageSize(image);
    ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);

    if(texelCoord.x < size.x && texelCoord.y < size.y)
    {
		vec2 screenSpaceUV = vec2((gl_GlobalInvocationID.xy / size) - 0.5) * 2.0;

		vec4 rayDirection = camera.rotation * camera.inverseProjection *  vec4(screenSpaceUV,1.0,1.0);
		rayDirection /= rayDirection.w;

		dvec3 skyColor = computeAtmosphereLight(camera.cameraPosition, normalize(rayDirection.xyz));

		imageStore(image, texelCoord, vec4(skyColor, 1.0));
	}
}