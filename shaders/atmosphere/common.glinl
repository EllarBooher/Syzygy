// Hard coded values (temporarily)
const float PLANET_RADIUS_KM = 6360.0;
const float ATMOSPHERE_RADIUS_KM = 6420.0;

const float DENSITY_SCALE_MIE_KM = 1.2;
const float DENSITY_SCALE_RAYLEIGH_KM = 8.0;
 
const int TRANSMITTANCE_LUT_WIDTH = 512;
const int TRANSMITTANCE_LUT_HEIGHT = 128;

const float VIEW_ALTITUDE_KM = 0.0;

const vec3 SCATTERING_COEF_RAYLEIGH_PER_MM = vec3(5.802, 13.558, 33.1);
// const vec3 ABSORPTION_COEF_RAYLEIGH_PER_MM = vec3(0.0);

const vec3 SCATTERING_COEF_MIE_PER_MM = vec3(3.996);
const vec3 ABSORPTION_COEF_MIE_PER_MM = vec3(4.40);

// const vec3 SCATTERING_COEF_OZONE_PER_MM = vec3(0.0);
const vec3 ABSORPTION_COEF_OZONE_PER_MM = vec3(0.650, 1.881, 0.085);

const float PI = 3.141592653589793;

const vec3 INCIDENT_DIRECTION_SUN = normalize(vec3(0.0,-1.0, -1.0));
const vec3 SUN_INTENSITY = vec3(12.0);

// Transmittance LUT UV mapping based on Bruneton et al. 2017 method
// https://ebruneton.github.io/precomputed_atmospheric_scattering/atmosphere/functions.glsl#transmittance_lookup

float safeSqrt(float value)
{
    return sqrt(max(value, 0.0));
}

// Squeeze in UV values by half a texel, so the boundaries of our sampled function can be stored precisely at the 
// boundary of the texture
float textureCoordFromUnitRange(float value, int dimension)
{
    return 0.5 / float(dimension) + value * (1.0 - 1.0 / float(dimension));
}
float unitRangeFromTextureCoord(float texCoord, int dimension)
{
    return (texCoord - 0.5 / float(dimension)) / (1.0 - 1.0 / float(dimension));
}

// Radius is the distance in Mm from the center of the planet, aka length of position vector
// Mu is the cosine of the angle between the position vector and the direction vector we want to sample the transmittance in
vec2 transmittanceLUT_RMu_to_UV(const float radius, const float mu)
{
    const float atmospherRadiusMmSquared = (ATMOSPHERE_RADIUS_KM / 1000.0) * (ATMOSPHERE_RADIUS_KM / 1000.0);
    const float planetRadiusMmSquared = (PLANET_RADIUS_KM / 1000.0) * (PLANET_RADIUS_KM / 1000.0);

    // Ground level, horizontal ray distance to atmospheric boundary
    const float H = sqrt(atmospherRadiusMmSquared - planetRadiusMmSquared);

    // Distance to horizon, which is also the exact position the previous horizontal ray starts at
    const float rho = sqrt(radius * radius - planetRadiusMmSquared);

    // rho + H = distance to atmosphere boundary when looking at the horizon
    // It represents the distance along the biggest angle (most negative mu) that has nonzero transmittance, 
    // since any lower and we intersect the planet
    // This angle changes as the radius does, so this mapping seeks to compress a different range of mu values
    // at any given radius value

    // Distance to edge of atmosphere, with both its min and max values at this given radius. 
    const float d = max(-radius * mu + safeSqrt(radius * radius * (mu * mu - 1.0) + atmospherRadiusMmSquared), 0.0);
    const float d_min = ATMOSPHERE_RADIUS_KM / 1000.0 - radius;
    const float d_max = rho + H;

    const float x_mu = (d - d_min) / (d_max - d_min);
    const float x_radius = rho / H;

    return vec2(textureCoordFromUnitRange(x_mu, TRANSMITTANCE_LUT_WIDTH), textureCoordFromUnitRange(x_radius, TRANSMITTANCE_LUT_HEIGHT));
}

// Inverse of transmittanceLUT_RMu_to_UV
vec2 transmittanceLUT_UV_to_RMu(const vec2 uv)
{
    const float x_mu = unitRangeFromTextureCoord(uv.s, TRANSMITTANCE_LUT_WIDTH);
    const float x_radius = unitRangeFromTextureCoord(uv.t, TRANSMITTANCE_LUT_HEIGHT);

    const float atmospherRadiusMmSquared = (ATMOSPHERE_RADIUS_KM / 1000.0) * (ATMOSPHERE_RADIUS_KM / 1000.0);
    const float planetRadiusMmSquared = (PLANET_RADIUS_KM / 1000.0) * (PLANET_RADIUS_KM / 1000.0);

    // Ground level, horizontal ray distance to atmospheric boundary
    const float H = sqrt(atmospherRadiusMmSquared - planetRadiusMmSquared);

    const float rho = H * x_radius;

    const float radius = sqrt(rho * rho + planetRadiusMmSquared);

    const float d_min = ATMOSPHERE_RADIUS_KM / 1000.0 - radius;
    const float d_max = rho + H;

    const float d = (d_max - d_min) * x_mu + d_min;

    if (d == 0.0)
    {
        // mu is ambiguous since we are at the very edge of the atmosphere, where no angle produces valid transmittance values
        return vec2(radius, 1.0);
    }

    const float mu = (H * H - rho * rho - d * d) / (2.0 * radius * d);
    // Equivalenty, mu = (atmospherRadiusMmSquared - radius * radius - d*d) / (2.0 * radius * d)
    // But atmospherRadiusMmSquared and radius * radius are large, so this avoids floating point errors from adding 
    // these to the much smaller d * d

    // This clamp is very important
    return vec2(radius, clamp(mu, -1.0, 1.0));
}

// Altitude density distributions for Rayleigh, Mie, and Ozone media.
// Suggested values for densityScale are 8 km for Rayleigh, and 1.2 km for Mie
float altitudeDensityRayleighMie(const float altitude_km, const float densityScale_km)
{
    return exp(-altitude_km / densityScale_km);
}

float altitudeDensityOzone(const float altitude_km) { return max(0.0, 1.0 - abs(altitude_km - 25.0) / 15.0); }

struct ExtinctionSample
{
    vec3 scatteringRayleigh;
    vec3 scatteringMie;

    vec3 absorptionMie;
    vec3 absorptionOzone;

    vec3 extinction;
};

// Returned units are per MM
ExtinctionSample sampleExtinction(const float altitude_km)
{
    const float densityRayleigh = altitudeDensityRayleighMie(altitude_km, DENSITY_SCALE_RAYLEIGH_KM);
    const vec3 scatteringRayleigh = SCATTERING_COEF_RAYLEIGH_PER_MM * densityRayleigh;
    // const vec3 absorptionRayleigh = ABSORPTION_COEF_RAYLEIGH_PER_MM * densityRayleigh;

    const float densityMie = altitudeDensityRayleighMie(altitude_km, DENSITY_SCALE_MIE_KM);
    const vec3 scatteringMie = SCATTERING_COEF_MIE_PER_MM * densityMie;
    const vec3 absorptionMie = ABSORPTION_COEF_MIE_PER_MM * densityMie;

    const float densityOzone = altitudeDensityOzone(altitude_km);
    // const vec3 scatteringOzone = SCATTERING_COEF_OZONE_PER_MM * densityOzone;
    const vec3 absorptionOzone = ABSORPTION_COEF_OZONE_PER_MM * densityOzone;

    ExtinctionSample extinctionSample;
    extinctionSample.scatteringRayleigh = scatteringRayleigh;
    extinctionSample.scatteringMie = scatteringMie;
    extinctionSample.absorptionMie = absorptionMie;
    extinctionSample.absorptionOzone = absorptionOzone;
    extinctionSample.extinction = scatteringRayleigh + scatteringMie + absorptionMie + absorptionOzone;

    return extinctionSample;
}

// t1 > t0, values can be negative. Function returns true even if the sphere is behind the ray.
// If this returns false, t0 and t1 are unchanged.
bool raySphereIntersection(vec3 rayOrigin, vec3 rayDirectionNormalized, float radius, out float t0, out float t1)
{
    // Method taken from "Precision Improvements for Ray/Sphere Intersection"
    // by Eric Haines, Johannes Günther, and Tomas Akenine-Möller
    //
    // The method includes tricks to reduce float point inaccuracy errors.

    const vec3 f = rayOrigin;
    const vec3 d = rayDirectionNormalized;
    const float b = -1.0 * dot(f, d);
    const vec3 centerToIntersectionChord = f + b * d;
    const float discriminant = radius * radius - dot(centerToIntersectionChord, centerToIntersectionChord);
    const float c = dot(f, f) - radius * radius;

    if (discriminant < 0.0)
    {
        return false;
    }

    float q = b;
    if (b < 0.0)
    {
        q -= sqrt(discriminant);
    }
    else
    {
        q += sqrt(discriminant);
    }

    t0 = c / q;
    t1 = q;

    if (t0 > t1)
    {
        const float temp = t0;
        t0 = t1;
        t1 = temp;
    }

    return true;
}