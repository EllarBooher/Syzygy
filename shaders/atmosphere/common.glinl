#include "../types/atmosphere.glinl"

const int TRANSMITTANCE_LUT_WIDTH = 512;
const int TRANSMITTANCE_LUT_HEIGHT = 128;

const float VIEW_ALTITUDE_KM = 0.0;

// Hand computed from assumption that sun is roughly 32 arcminutes
const float SUN_ANGULAR_RADIUS_RADIANS = 0.009308422677303;

const float PI = 3.141592653589793;

// Transmittance LUT UV mapping based on Bruneton et al. 2017 method
// https://ebruneton.github.io/precomputed_atmospheric_scattering/atmosphere/functions.glsl#transmittance_lookup

float safeSqrt(float value)
{
    return sqrt(max(value, 0.0));
}

// Squeeze in UV values by half a texel, so the bounds of our sampled function can be stored precisely at the edge of the texture
float textureCoordFromUnitRange(float value, int dimension)
{
    return 0.5 / float(dimension) + value * (1.0 - 1.0 / float(dimension));
}
float unitRangeFromTextureCoord(float texCoord, int dimension)
{
    return (texCoord - 0.5 / float(dimension)) / (1.0 - 1.0 / float(dimension));
}

// Radius is the distance in Mm from the center of the planet, aka length of position vector
// Mu is the cosine of the angle between the position vector and the direction vector we want to sample the transmittance in
vec2 transmittanceLUT_RMu_to_UV(const Atmosphere atmosphere, const float radius, const float mu)
{
    const float atmospherRadiusMmSquared = atmosphere.atmosphereRadiusMm * atmosphere.atmosphereRadiusMm;
    const float planetRadiusMmSquared = atmosphere.planetRadiusMm * atmosphere.planetRadiusMm;

    // Ground level, horizontal ray distance to atmospheric boundary
    const float H = sqrt(atmospherRadiusMmSquared - planetRadiusMmSquared);

    // Distance to horizon, which is also the exact position the previous horizontal ray starts at
    const float rho = sqrt(radius * radius - planetRadiusMmSquared);

    // rho + H = distance to atmosphere boundary when looking at the horizon
    // It represents the distance along the biggest angle (most negative mu) that has nonzero transmittance, 
    // since any lower and we intersect the planet
    // This angle changes as the radius does, so this mapping seeks to compress a different range of mu values
    // at any given radius value

    // Distance to edge of atmosphere, with both its min and max values at this given radius. 
    const float d = max(-radius * mu + safeSqrt(radius * radius * (mu * mu - 1.0) + atmospherRadiusMmSquared), 0.0);
    const float d_min = atmosphere.atmosphereRadiusMm - radius;
    const float d_max = rho + H;

    const float x_mu = (d - d_min) / (d_max - d_min);
    const float x_radius = rho / H;

    return vec2(textureCoordFromUnitRange(x_mu, TRANSMITTANCE_LUT_WIDTH), textureCoordFromUnitRange(x_radius, TRANSMITTANCE_LUT_HEIGHT));
}

// Inverse of transmittanceLUT_RMu_to_UV
vec2 transmittanceLUT_UV_to_RMu(const Atmosphere atmosphere, const vec2 uv)
{
    const float x_mu = unitRangeFromTextureCoord(uv.s, TRANSMITTANCE_LUT_WIDTH);
    const float x_radius = unitRangeFromTextureCoord(uv.t, TRANSMITTANCE_LUT_HEIGHT);

    const float atmospherRadiusMmSquared = atmosphere.atmosphereRadiusMm * atmosphere.atmosphereRadiusMm;
    const float planetRadiusMmSquared = atmosphere.planetRadiusMm * atmosphere.planetRadiusMm;

    // Ground level, horizontal ray distance to atmospheric boundary
    const float H = sqrt(atmospherRadiusMmSquared - planetRadiusMmSquared);

    const float rho = H * x_radius;

    const float radius = sqrt(rho * rho + planetRadiusMmSquared);

    const float d_min = atmosphere.atmosphereRadiusMm - radius;
    const float d_max = rho + H;

    const float d = (d_max - d_min) * x_mu + d_min;

    if (d == 0.0)
    {
        // mu is ambiguous since we are at the very edge of the atmosphere, where no angle produces valid transmittance values
        return vec2(radius, 1.0);
    }

    const float mu = (H * H - rho * rho - d * d) / (2.0 * radius * d);
    // Equivalenty, mu = (atmospherRadiusMmSquared - radius * radius - d*d) / (2.0 * radius * d)
    // But atmospherRadiusMmSquared and radius * radius are large, so this avoids floating point errors from adding 
    // these to the much smaller d * d

    // This clamp is very important
    return vec2(radius, clamp(mu, -1.0, 1.0));
}

vec3 sampleTransmittanceLUT_Ray(sampler2D LUT, const Atmosphere atmosphere, const vec3 position, const vec3 direction)
{
    const float radius = length(position);
    const float mu = (dot(position, direction) / (length(position) * length(direction)));

    const vec2 uv = transmittanceLUT_RMu_to_UV(atmosphere, radius, mu);

    return texture(LUT, uv).rgb;
}

// Ensure altitude and densityScale are the same units.
float densityExponential(const float altitude, const float densityScale)
{
    return exp(-altitude / densityScale);
}

// Hardcoded with values for ozone
float densityTent(const float altitude_km) { return max(0.0, 1.0 - abs(altitude_km - 25.0) / 15.0); }

struct ExtinctionSample
{
    vec3 scatteringRayleigh;
    vec3 scatteringMie;

    vec3 absorptionMie;
    vec3 absorptionOzone;

    vec3 extinction;
};

// Returned units are per Mm
ExtinctionSample sampleExtinction(const Atmosphere atmosphere, const float altitude_Mm)
{
    const float densityRayleigh = densityExponential(altitude_Mm, atmosphere.densityScaleRayleighMm);
    const vec3 scatteringRayleigh = atmosphere.scatteringRayleighPerMm * densityRayleigh;
    const vec3 absorptionRayleigh = atmosphere.absorptionRayleighPerMm * densityRayleigh;

    const float densityMie = densityExponential(altitude_Mm, atmosphere.densityScaleMieMm);
    const vec3 scatteringMie = atmosphere.scatteringMiePerMm * densityMie;
    const vec3 absorptionMie = atmosphere.absorptionRayleighPerMm * densityMie;

    const float densityOzone = densityTent(altitude_Mm * 1000.0);
    const vec3 scatteringOzone = atmosphere.scatteringOzonePerMm * densityOzone;
    const vec3 absorptionOzone = atmosphere.absorptionOzonePerMm * densityOzone;

    ExtinctionSample extinctionSample;
    extinctionSample.scatteringRayleigh = scatteringRayleigh;
    extinctionSample.scatteringMie = scatteringMie;
    extinctionSample.absorptionMie = absorptionMie;
    extinctionSample.absorptionOzone = absorptionOzone;
    extinctionSample.extinction = scatteringRayleigh + absorptionRayleigh + scatteringMie + absorptionMie + scatteringOzone + absorptionOzone;

    return extinctionSample;
}

// t1 > t0, values can be negative. Function returns true even if the sphere is behind the ray.
// If this returns false, t0 and t1 are unchanged.
bool raySphereIntersection(vec3 rayOrigin, vec3 rayDirectionNormalized, float radius, out float t0, out float t1)
{
    // Method taken from "Precision Improvements for Ray/Sphere Intersection"
    // by Eric Haines, Johannes Günther, and Tomas Akenine-Möller
    //
    // The method includes tricks to reduce float point inaccuracy errors.

    const vec3 f = rayOrigin;
    const vec3 d = rayDirectionNormalized;
    const float b = -1.0 * dot(f, d);
    const vec3 centerToIntersectionChord = f + b * d;
    const float discriminant = radius * radius - dot(centerToIntersectionChord, centerToIntersectionChord);
    const float c = dot(f, f) - radius * radius;

    if (discriminant < 0.0)
    {
        return false;
    }

    float q = b;
    if (b < 0.0)
    {
        q -= sqrt(discriminant);
    }
    else
    {
        q += sqrt(discriminant);
    }

    t0 = c / q;
    t1 = q;

    if (t0 > t1)
    {
        const float temp = t0;
        t0 = t1;
        t1 = temp;
    }

    return true;
}