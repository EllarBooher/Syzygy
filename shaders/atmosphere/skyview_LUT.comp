#version 460
#extension GL_EXT_buffer_reference2 : require
#extension GL_ARB_shading_language_include : require

layout(local_size_x = 16, local_size_y = 16) in;
layout(rgba32f, set = 0, binding = 0) uniform image2D skyview_LUT;
layout(set = 0, binding = 1) uniform sampler2D transmittance_LUT;

#include "common.glinl"

layout(buffer_reference, std430) readonly buffer AtmosphereBuffer
{
    Atmosphere atmospheres[];
};

layout(push_constant) uniform PushConstant
{
    AtmosphereBuffer atmosphereBuffer;

    uint atmosphereIndex;
} pc;

// Based on "A Scalable and Production Ready Sky and Atmosphere Rendering Technique" by Sebastien Hillaire
//
// And also "Precomputed Atmospheric Scattering: a New Implementation" by Eric Bruneton
// https://ebruneton.github.io/precomputed_atmospheric_scattering

// All units are Mm/megameters (10^6 meters) unless marked km/kilometers (10^3 meters)

// This shader builds a 2D sky-view LUT, which is a lattitude-longitude map of
// the sky with only the planet's surface shadowing.
// This map contains the total luminance from in-scattering due to atmospheric effects.
//
// TODO: Work remains to figure out how to compose this map with local lights i.e. punctual lights.
// For now the best thing to do is to light surface geometry without scattering,
// then compose that with the transmittance from camera to fragment position.
// This works well for thin atmospheres and lights that are close to their geometry.
//
// This map only depends on altitude, and allows the camera to be freely rotated
// without requiring recomputation. There is even an acceptable degree of movement
// by the camera. Within a range of the provided altitude.
//
// Parameterized as follows:
// u := azimuth angle
// u varies from -pi to pi
//
// v := solar elevation
// v varies from -pi/2 to pi/2

void uv_to_azimuthElevation(const Atmosphere atmosphere, const vec2 uv, out float azimuth, out float elevation)
{
    // Horizon zenith cannot be less than PI/2, so we use sin and assume it is a quadrant 2 angle
    const float sinHorizonZenith = atmosphere.planetRadiusMm / (atmosphere.planetRadiusMm + VIEW_ALTITUDE_MM);
    const float horizonZenith = PI - asin(sinHorizonZenith);

    // u stores light-relative azimuth
    const float cosineViewLightProjected = (uv.s - 0.5) * 2.0;
    const vec2 lightDirectionProjected = normalize(vec2(-atmosphere.incidentDirectionSun.x, -atmosphere.incidentDirectionSun.z));

    float azimuthSun = asin(lightDirectionProjected.x);
    if (lightDirectionProjected.y < 0.0)
    {
        azimuthSun = PI - azimuthSun;
    }

    azimuth = acos(clamp(cosineViewLightProjected, -1.0, 1.0)) + azimuthSun;

    float viewZenith;

    if (uv.t < 0.5)
    {
        const float unnormalized_v = 2.0 * uv.t - 1.0;
        const float angleFraction = 1.0 - unnormalized_v * unnormalized_v;

        viewZenith = angleFraction * horizonZenith;
    }
    else
    {
        const float unnormalized_v = 2.0 * uv.t - 1.0;
        const float angleFraction = unnormalized_v * unnormalized_v;

        viewZenith = (PI - horizonZenith) * angleFraction + horizonZenith;
    }

    elevation = -(viewZenith - PI / 2.0);
}

// Input cosine is the cosine of the angle between incident and outgoing scattering directions
float phaseRayleigh(const float cosine)
{
    const float scalar = 3.0 / (16.0 * PI);
    const float numerator = (1.0 + cosine * cosine);

    return scalar * numerator;
}
// Input cosine is the cosine of the angle between incident and outgoing scattering directions
// Input g is a value from -1 to 1 that controls the concentration of back vs forward scattering.
// Note: g = 0 reduces to the case of our rayleigh phase function
float phaseMie(const float cosine, const float g)
{
    const float scalar = 3.0 / (8.0 * PI);
    const float numerator = (1.0 - g * g) * (1.0 + cosine * cosine);
    const float denominator = (2.0 + g * g) * pow(1.0 + g * g - 2.0 * g * cosine, 1.5);
    return scalar * numerator / denominator;
}

// Not in use for now, intended for estimating multi-scattering
const float phaseIsotropic = 1.0 / (4.0 * PI);

void raycastAtmosphere(const Atmosphere atmosphere, const vec3 origin, const vec3 direction, out float atmosphereDistance)
{
    float atmosphere_t0, atmosphere_t1;
    const bool hitAtmosphere =
        raySphereIntersection(origin, direction, atmosphere.atmosphereRadiusMm, atmosphere_t0, atmosphere_t1)
        && atmosphere_t1 > 0.0;

    atmosphereDistance = 0.0;
    atmosphere_t0 = max(0.0, atmosphere_t0);

    // TODO: Figure out what to do when inside the planet
    float planet_t0, planet_t1;
    const bool hitPlanet =
        raySphereIntersection(origin, direction, atmosphere.planetRadiusMm, planet_t0, planet_t1) && planet_t0 > 0.0;
    if (hitPlanet)
    {
        atmosphere_t1 = min(planet_t0, atmosphere_t1);
    }

    if (hitAtmosphere)
    {
        atmosphereDistance = atmosphere_t1 - atmosphere_t0;
    }
}

struct RaymarchStep
{
    float radius;
    float mu;
    float mu_sun;
};

RaymarchStep stepRadiusMu(const RaymarchStep start, const float stepDistance)
{
    // Consider starting position (0, radius, 0) 
    // and step vector of d * (sqrt(1 - mu * mu), mu, 0)

    // When computing changes in radii and mu, we use this method everywhere since norm is preserved upon rotation 
    // and all cases of stepping can be reduced to the above two vectors

    // cosine sum identity for sun zenith and direction zenith
    const float mu_sunAndStepDirection = safeSqrt(start.mu_sun * start.mu - safeSqrt((1.0 - start.mu_sun * start.mu_sun) * (1.0 - start.mu * start.mu)));

    RaymarchStep result;

    result.radius = safeSqrt(stepDistance * stepDistance + 2.0 * start.radius * start.mu * stepDistance + start.radius * start.radius);
    result.mu = (start.radius * start.mu + stepDistance) / result.radius;
    result.mu_sun = (start.radius * start.mu_sun + stepDistance * mu_sunAndStepDirection) / result.radius;

    return result;
}

vec3 sampleTransmittanceLUT_RayMarchStep(const Atmosphere atmosphere, const RaymarchStep start, const float stepDistance)
{
    if (stepDistance < 0.0000001)
    {   
        return vec3(1.0);
    }

    const RaymarchStep end = stepRadiusMu(start, stepDistance);

    vec3 transmittance;
    if (start.mu > 0.0)
    {
        // Oriented up into atmosphere, so we directly sample LUT
        transmittance = sampleTransmittanceLUT_RadiusMu(transmittance_LUT, atmosphere, start.radius, start.mu) 
            / sampleTransmittanceLUT_RadiusMu(transmittance_LUT, atmosphere, end.radius, end.mu);
    }
    else
    {
        // Oriented down towards planet, so direct samples would be invalid
        // Instead, we flip the direction
        transmittance = sampleTransmittanceLUT_RadiusMu(transmittance_LUT, atmosphere, end.radius, -end.mu) 
            / sampleTransmittanceLUT_RadiusMu(transmittance_LUT, atmosphere, start.radius, -start.mu);
    }

    return clamp(transmittance, 0.0, 1.0);
}

const uint SKY_VIEW_LUT_SAMPLE_COUNT = 32;
vec3 computeLuminanceScatteringIntegral(const Atmosphere atmosphere, const vec3 origin, const vec3 direction, const float sampleDistance)
{
    // This is the direction of the incoming light, which is the light we are interested in computing the magnitude of.
    // For the purposes of calculating phase functions, this is the direction we want to use.
    const vec3 scatteringDir = -normalize(direction);

    const float radius = length(origin);
    const float mu = dot(origin, direction) / (length(origin) * length(direction));
    const float mu_sun = dot(origin, -atmosphere.incidentDirectionSun) / (length(origin) * length(atmosphere.incidentDirectionSun));

    const RaymarchStep originStep = RaymarchStep(radius, mu, mu_sun);

    vec3 luminance = vec3(0.0);

    vec3 transmittance = vec3(1.0);

    // We estimate the integral in Equation (1) of Hillaire's paper.

    const float dSampleDistance = sampleDistance / SKY_VIEW_LUT_SAMPLE_COUNT;
    for (uint i = 0; i < SKY_VIEW_LUT_SAMPLE_COUNT; i++)
    {
        const float t = i * dSampleDistance;
        const vec3 begin = origin - (float(i) * dSampleDistance) * scatteringDir;
        const vec3 end = origin - (float(i + 1) * dSampleDistance) * scatteringDir;

        const RaymarchStep sampleStep = stepRadiusMu(originStep, t);

        const float altitude = length(begin) - atmosphere.planetRadiusMm;

        const vec3 transmittanceToSun = sampleTransmittanceLUT_Sun(transmittance_LUT, atmosphere, sampleStep.radius, sampleStep.mu_sun);

        const ExtinctionSample extinctionSample = sampleExtinction(atmosphere, altitude);

        // Terms of Equation (3) we assume to not vary over the path segment

        // We could accumulate samples across loops like:
        //
        // const vec3 sampleTransmittance = exp(-dSampleDistance * extinctionSample.extinction);
        // ... compute luminance using transmittance ...
        // transmittance *= sampleTransmittance;
        //
        // But at the cost of performance, resampling the transmittance LUT is more accurate for larger step sizes

        const vec3 transmittanceToBegin = sampleTransmittanceLUT_RayMarchStep(atmosphere, originStep, t);
        const float incidentCosine = dot(atmosphere.incidentDirectionSun, scatteringDir);
        const vec3 phaseTimesScattering = extinctionSample.scatteringRayleigh * phaseRayleigh(incidentCosine)
                                        + extinctionSample.scatteringMie * phaseMie(incidentCosine, 0.8);
        const vec3 shadowing = transmittanceToSun;

        // Integrate transmittance := e^(-extinction(x) * ||x - begin||) from begin to end
        // This is a single interval of the integral in Equation (1) from Hillaire's paper,
        // with all constant terms factored out above
        const vec3 transmittanceAlongPath = sampleTransmittanceLUT_Segment(transmittance_LUT, atmosphere, begin, end);
        const vec3 scatteringIlluminanceIntegral = (vec3(1.0) - transmittanceAlongPath) / extinctionSample.extinction;

        luminance += phaseTimesScattering * shadowing * scatteringIlluminanceIntegral
                    * transmittanceToBegin;
    }

    return luminance;
}

void main()
{
    const vec2 size = imageSize(skyview_LUT);
    const ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);
    if (texelCoord.x >= size.x || texelCoord.y >= size.y)
    {
        return;
    }

    const vec2 offset = vec2(0.5, 0.5);
    const vec2 uv = (vec2(texelCoord) + offset) / size;
    
    const Atmosphere atmosphere = pc.atmosphereBuffer.atmospheres[pc.atmosphereIndex];

    float azimuth;
    float elevation;
    uv_to_azimuthElevation(atmosphere, uv, azimuth, elevation);
        
    // +x right, +y up, +z forward
    // Note: engine has +y down, but these coordinates are separate and based on azimuth, elevation.
    // +azimuth right, +elevation up

    const vec3 origin = vec3(0.0, atmosphere.planetRadiusMm + VIEW_ALTITUDE_MM, 0.0);
    const vec3 direction =
        normalize(vec3(sin(azimuth) * cos(elevation), sin(elevation), cos(azimuth) * cos(elevation)));

    float distanceThroughAtmosphere;
    raycastAtmosphere(atmosphere, origin, direction, distanceThroughAtmosphere);

    const vec3 luminance = computeLuminanceScatteringIntegral(atmosphere, origin, direction, distanceThroughAtmosphere);

    imageStore(skyview_LUT, texelCoord, vec4(luminance, 1.0));
}