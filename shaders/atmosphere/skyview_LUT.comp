#version 460
#extension GL_EXT_buffer_reference2 : require
#extension GL_ARB_shading_language_include : require

layout(local_size_x = 16, local_size_y = 16) in;
layout(rgba32f, set = 0, binding = 0) uniform image2D skyview_LUT;
layout(set = 0, binding = 1) uniform sampler2D transmittance_LUT;

#include "common.glinl"

layout(buffer_reference, std430) readonly buffer AtmosphereBuffer
{
    Atmosphere atmospheres[];
};

layout(push_constant) uniform PushConstant
{
    AtmosphereBuffer atmosphereBuffer;

    uint atmosphereIndex;
} pc;

// Based on "A Scalable and Production Ready Sky and Atmosphere Rendering Technique" by Sebastien Hillaire
//
// And also "Precomputed Atmospheric Scattering: a New Implementation" by Eric Bruneton
// https://ebruneton.github.io/precomputed_atmospheric_scattering

// All units are Mm/megameters (10^6 meters) unless marked km/kilometers (10^3 meters)

// This shader builds a 2D sky-view LUT, which is a lattitude-longitude map of
// the sky with only the planet's surface shadowing.
// This map contains the total luminance from in-scattering due to atmospheric effects.
//
// TODO: Work remains to figure out how to compose this map with local lights i.e. punctual lights.
// For now the best thing to do is to light surface geometry without scattering,
// then compose that with the transmittance from camera to fragment position.
// This works well for thin atmospheres and lights that are close to their geometry.
//
// This map only depends on altitude, and allows the camera to be freely rotated
// without requiring recomputation. There is even an acceptable degree of movement
// by the camera. Within a range of the provided altitude.
//
// Parameterized as follows:
// u := azimuth angle
// u varies from -pi to pi
//
// v := solar elevation
// v varies from -pi/2 to pi/2

void uv_to_azimuthElevation(const vec2 uv, out float azimuth, out float elevation)
{
    azimuth = mix(-PI, PI, uv.s);

    // Undo v compression that allocates more texels to the horizon
    // v = 0.5 + 0.5 * sign(elevation) * sqrt(|elevation| / (pi/2))

    const float unnormalized_v = 2.0 * (uv.t - 0.5);
    elevation = sign(unnormalized_v) * unnormalized_v * unnormalized_v * PI / 2.0;
}

// Input cosine is the cosine of the angle between incident and outgoing scattering directions
float phaseRayleigh(const float cosine)
{
    const float scalar = 3.0 / (16.0 * PI);
    const float numerator = (1.0 + cosine * cosine);

    return scalar * numerator;
}
// Input cosine is the cosine of the angle between incident and outgoing scattering directions
// Input g is a value from -1 to 1 that controls the concentration of back vs forward scattering.
// Note: g = 0 reduces to the case of our rayleigh phase function
float phaseMie(const float cosine, const float g)
{
    const float scalar = 3.0 / (8.0 * PI);
    const float numerator = (1.0 - g * g) * (1.0 + cosine * cosine);
    const float denominator = (2.0 + g * g) * pow(1.0 + g * g - 2.0 * g * cosine, 1.5);
    return scalar * numerator / denominator;
}

// Not in use for now, intended for estimating multi-scattering
const float phaseIsotropic = 1.0 / (4.0 * PI);

vec3 sampleTransmittanceLUT_Ray(const Atmosphere atmosphere, const float radius, const float mu)
{
    const vec2 uv = transmittanceLUT_RMu_to_UV(atmosphere, radius, mu);

    return texture(transmittance_LUT, uv).rgb;
}

vec3 sampleTransmittanceLUT_Segment(const Atmosphere atmosphere, const vec3 from, const vec3 to)
{
    // Floats do not have enough range to store the very low transmittance of a ray crossing the longest distances.
    // Thus, a sliver of the transmittance LUT near the horizon is zero when it should be a very small value.
    // Also, rays that point at the planet return a transmittance of exactly 0 making it impossible to use such samples.
    // Thus, we sometimes swap the rays depending on how they are oriented.

    vec3 transmittance;
    vec3 direction = normalize(to - from);

    if (length(direction) < 0.99)
    {
        return vec3(1.0);
    }

    if (dot(direction, from) > 0.0)
    {
        transmittance = sampleTransmittanceLUT_Ray(transmittance_LUT, atmosphere, from, direction) / sampleTransmittanceLUT_Ray(transmittance_LUT, atmosphere, to, direction);
    }
    else
    {
        transmittance = sampleTransmittanceLUT_Ray(transmittance_LUT, atmosphere, to, -direction) / sampleTransmittanceLUT_Ray(transmittance_LUT, atmosphere, from, -direction);
    }

    return clamp(transmittance, 0.0, 1.0);
}

vec3 sampleTransmittanceLUT_Sun(const Atmosphere atmosphere, const float radius, const float cos_sunZenith)
{
    const float sin_sunRadius = sin(SUN_ANGULAR_RADIUS_RADIANS);
    const float cos_sunRadius = cos(SUN_ANGULAR_RADIUS_RADIANS);

    /* 
    Possible small angle approximation
    const float sin_sunRadius = SUN_ANGULAR_RADIUS_RADIANS;
    const float cos_sunRadius = 1.0;
    */

    const float sin_horizonZenith = atmosphere.planetRadiusMm / radius;
    // Negative since the horizon zenith varies from PI/2 to PI
    const float cos_horizonZenith = -safeSqrt(1.0 - sin_horizonZenith * sin_horizonZenith);

    // This sample makes no assumption about ground intersection
    const vec3 transmittanceThroughAtmosphere = sampleTransmittanceLUT_Ray(atmosphere, radius, cos_sunZenith);

    // angularFactor goes from 1 to 0 as sunZenith varies from horizonZenith - sunRadius to horizonZenith + sunRadius
    // Or as cos(sunZenith) varies from cos(horizonZenith - sunRadius) to cos(horizonZenith + sunRadius)
    // Using angle sum identity, we get that:
    // cos(horizonZenith - sunRadius) = cos(horizonZenith)cos(sunRadius) + sin(sunRadius)sin(horizonZenith)
    // cos(horizonZenith + sunRadius) = cos(horizonZenith)cos(sunRadius) - sin(sunRadius)sin(horizonZenith)
    
    const float angularFactor = smoothstep(-sin_horizonZenith * sin_sunRadius, sin_horizonZenith * sin_sunRadius, cos_sunZenith - cos_horizonZenith * cos_sunRadius);

    return transmittanceThroughAtmosphere * angularFactor;
}

void raycastAtmosphere(const Atmosphere atmosphere, const vec3 origin, const vec3 direction, out vec3 l_naught, out float atmosphereDistance)
{
    float atmosphere_t0, atmosphere_t1;
    const bool hitAtmosphere =
        raySphereIntersection(origin, direction, atmosphere.atmosphereRadiusMm, atmosphere_t0, atmosphere_t1)
        && atmosphere_t1 > 0.0;

    atmosphereDistance = 0.0;
    atmosphere_t0 = max(0.0, atmosphere_t0);

    l_naught = vec3(0.0);

    vec3 luminance = vec3(0.0);
    vec3 transmittance = vec3(1.0);

    // TODO: Figure out what to do when inside the planet
    float planet_t0, planet_t1;
    const bool hitPlanet =
        raySphereIntersection(origin, direction, atmosphere.planetRadiusMm, planet_t0, planet_t1) && planet_t0 > 0.0;
    if (hitPlanet)
    {
        atmosphere_t1 = min(planet_t0, atmosphere_t1);

        const vec3 surfacePosition = origin + planet_t0 * direction;
        const vec3 surfaceNormal = normalize(surfacePosition);

        const vec3 lightDirection = -atmosphere.incidentDirectionSun;
        const vec3 viewDirection = -direction;
        // Quick and dirty estimate of surface albedo
        const vec3 halfwayDirection = normalize(lightDirection + viewDirection);
        const float specularPower = 160.0;
        const float microfacetAttenuation = pow(clamp(dot(halfwayDirection, surfaceNormal), 0.0, 1.0), specularPower);
        const float normalizationTerm = (specularPower + 2) / 8.0;
        const vec3 specular = vec3(normalizationTerm * microfacetAttenuation);
        const vec3 diffuse = vec3(0.4) / PI;

        const vec3 fresnel =
            vec3(0.04) + (1.0 - vec3(0.04)) * pow(1.0 - clamp(dot(halfwayDirection, lightDirection), 0.0, 1.0), 5);
        const vec3 albedo = mix(diffuse, specular, fresnel);

        luminance = sampleTransmittanceLUT_Ray(transmittance_LUT, atmosphere, surfacePosition, lightDirection) * albedo
                  * clamp(dot(surfaceNormal, lightDirection),0.0,1.0);
        transmittance = sampleTransmittanceLUT_Segment(atmosphere, surfacePosition, origin);
    }

    if (hitAtmosphere)
    {
        atmosphereDistance = atmosphere_t1 - atmosphere_t0;
    }

    l_naught = luminance * transmittance;
}

struct RaymarchStep
{
    float radius;
    float mu;
    float mu_sun;
};

RaymarchStep stepRadiusMu(const RaymarchStep start, const float stepDistance)
{
    // Consider starting position (0, radius, 0) 
    // and step vector of d * (sqrt(1 - mu * mu), mu, 0)

    // When computing changes in radii and mu, we use this method everywhere since norm is preserved upon rotation 
    // and all cases of stepping can be reduced to the above two vectors

    // cosine sum identity for sun zenith and direction zenith
    const float mu_sunAndStepDirection = safeSqrt(start.mu_sun * start.mu - safeSqrt((1.0 - start.mu_sun * start.mu_sun) * (1.0 - start.mu * start.mu)));

    RaymarchStep result;

    result.radius = safeSqrt(stepDistance * stepDistance + 2.0 * start.radius * start.mu * stepDistance + start.radius * start.radius);
    result.mu = (start.radius * start.mu + stepDistance) / result.radius;
    result.mu_sun = (start.radius * start.mu_sun + stepDistance * mu_sunAndStepDirection) / result.radius;

    return result;
}

const uint SKY_VIEW_LUT_SAMPLE_COUNT = 32;
vec3 computeLuminanceScatteringIntegral(const Atmosphere atmosphere, const vec3 origin, const vec3 direction, const float sampleDistance)
{
    // This is the direction of the incoming light, which is the light we are interested in computing the magnitude of.
    // For the purposes of calculating phase functions, this is the direction we want to use.
    const vec3 scatteringDir = -normalize(direction);

    const float radius = length(origin);
    const float mu = dot(origin, direction) / (length(origin) * length(direction));
    const float mu_sun = dot(origin, -atmosphere.incidentDirectionSun) / (length(origin) * length(atmosphere.incidentDirectionSun));

    const RaymarchStep originStep = RaymarchStep(radius, mu, mu_sun);

    vec3 luminance = vec3(0.0);

    // We estimate the integral in Equation (1) of Hillaire's paper.

    const float dSampleDistance = sampleDistance / SKY_VIEW_LUT_SAMPLE_COUNT;
    for (uint i = 0; i < SKY_VIEW_LUT_SAMPLE_COUNT; i++)
    {
        const float t = i * dSampleDistance;
        const vec3 begin = origin - (float(i) * dSampleDistance) * scatteringDir;
        const vec3 end = origin - (float(i + 1) * dSampleDistance) * scatteringDir;

        const RaymarchStep sampleStep = stepRadiusMu(originStep, t);

        // TODO: Possibly accumulate transmittance instead of sampling

        const float altitude = length(begin) - atmosphere.planetRadiusMm;

        const vec3 transmittanceToSun = sampleTransmittanceLUT_Sun(atmosphere, sampleStep.radius, sampleStep.mu_sun);

        const ExtinctionSample extinctionSample = sampleExtinction(atmosphere, altitude);

        // Terms of Equation (3) we assume to not vary over the path segment
        const vec3 transmittanceToBegin = sampleTransmittanceLUT_Segment(atmosphere, origin, begin);
        const float incidentCosine = dot(atmosphere.incidentDirectionSun, scatteringDir);
        const vec3 phaseTimesScattering = extinctionSample.scatteringRayleigh * phaseRayleigh(incidentCosine)
                                        + extinctionSample.scatteringMie * phaseMie(incidentCosine, 0.8);
        const vec3 shadowing = transmittanceToSun;

        // Integrate transmittance := e^(-extinction(x) * ||x - begin||) from begin to end
        // This is a single interval of the integral in Equation (1) from Hillaire's paper,
        // with all constant terms factored out above
        const vec3 transmittanceAlongPath = sampleTransmittanceLUT_Segment(atmosphere, begin, end);
        const vec3 transmittanceIntegral = (vec3(1.0) - transmittanceAlongPath) / extinctionSample.extinction;

        luminance += phaseTimesScattering * shadowing * transmittanceIntegral
                    * transmittanceToBegin;
    }

    return luminance;
}

void main()
{
    const vec2 size = imageSize(skyview_LUT);
    const ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);
    if (texelCoord.x >= size.x || texelCoord.y >= size.y)
    {
        return;
    }

    const vec2 offset = vec2(0.5, 0.5);
    const vec2 uv = (vec2(texelCoord) + offset) / size;

    float azimuth;
    float elevation;
    uv_to_azimuthElevation(uv, azimuth, elevation);
        
    const Atmosphere atmosphere = pc.atmosphereBuffer.atmospheres[pc.atmosphereIndex];

    // +x right, +y up, +z forward
    // Note: engine has +y down, but these coordinates are separate and based on azimuth, elevation.
    // +azimuth right, +elevation up

    const vec3 origin = vec3(0.0, atmosphere.planetRadiusMm + 0.000005, 0.0);
    const vec3 direction =
        normalize(vec3(sin(azimuth) * cos(elevation), sin(elevation), cos(azimuth) * cos(elevation)));

    vec3 l_naught;
    float distanceThroughAtmosphere;
    raycastAtmosphere(atmosphere, origin, direction, l_naught, distanceThroughAtmosphere);

    const vec3 luminance = l_naught + computeLuminanceScatteringIntegral(atmosphere, origin, direction, distanceThroughAtmosphere);

    imageStore(skyview_LUT, texelCoord, vec4(luminance, 1.0));
}