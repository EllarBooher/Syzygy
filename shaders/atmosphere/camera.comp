#version 460
#extension GL_EXT_buffer_reference2 : require
#extension GL_ARB_shading_language_include : require

#include "../types/camera.glsl"
#include "common.glinl"

// Perpsective projection of a map parameterized by
// u := azimuth from -pi to pi
// v := elevation from -pi/2 to pi/2

layout(local_size_x = 16, local_size_y = 16) in;
layout(rgba16, set = 0, binding = 0) uniform image2D image;
layout(set = 0, binding = 1) uniform sampler2D skyview_LUT;
layout(set = 0, binding = 2) uniform sampler2D transmittance_LUT;

layout(buffer_reference, std430) readonly buffer AtmosphereBuffer
{
    Atmosphere atmospheres[];
};

layout(buffer_reference, std430) readonly buffer CameraBuffer
{
    Camera cameras[];
};

layout(push_constant) uniform PushConstant
{
    AtmosphereBuffer atmosphereBuffer;
    CameraBuffer cameraBuffer;

    uint atmosphereIndex;
    uint cameraIndex;

    uvec2 drawExtent;
} pc;

vec3 sampleMap_Direction(const vec3 direction)
{
    const vec3 normalized = normalize(direction);

    const float elevation = asin(clamp(normalized.y, -1.0, 1.0));

    float azimuth = atan(normalized.x, normalized.z);
    if (normalized.z == 0.0)
    {
        azimuth = sign(normalized.x) * PI / 2.0;
    }

    const float u = (azimuth + PI) / (2.0 * PI);
    float v = 0.5 + 0.5 * sign(elevation) * sqrt(abs(elevation) / (PI / 2.0));

    return texture(skyview_LUT, vec2(u, v)).rgb;
}

vec3 sampleSunDisk(const Atmosphere atmosphere, const vec3 position, const vec3 direction)
{
    const vec3 directionToSun = -atmosphere.incidentDirectionSun;

    const float cosDirectionSun = dot(direction, directionToSun) / (length(direction) * length(directionToSun));

    const float sinSunRadius = SUN_ANGULAR_RADIUS_RADIANS;
    const float sinDirectionSun = safeSqrt(1.0 - cosDirectionSun * cosDirectionSun);

    const vec3 transmittanceToSun = sampleTransmittanceLUT_Ray(transmittance_LUT, atmosphere, position, direction);

    if (cosDirectionSun < 0.0)
    {
        return vec3(0.0);
    }

    return transmittanceToSun * (1.0 - smoothstep(0.2 * sinSunRadius, sinSunRadius, sinDirectionSun));
}

vec3 sampleGround(const Atmosphere atmosphere, const vec3 origin, const vec3 direction)
{
    // TODO: Figure out what to do when inside the planet
    float planet_t0, planet_t1;
    const bool hitPlanet =
        raySphereIntersection(origin, direction, atmosphere.planetRadiusMm, planet_t0, planet_t1) && planet_t0 > 0.0;
    
    if (!hitPlanet)
    {
        return vec3(0.0);
    }

    const vec3 surfacePosition = origin + planet_t0 * direction;
    const vec3 surfaceNormal = normalize(surfacePosition);

    const vec3 lightDirection = -atmosphere.incidentDirectionSun;
    const vec3 viewDirection = -direction;
    // Quick and dirty estimate of surface albedo
    const vec3 halfwayDirection = normalize(lightDirection + viewDirection);
    const float specularPower = 160.0;
    const float microfacetAttenuation = pow(clamp(dot(halfwayDirection, surfaceNormal), 0.0, 1.0), specularPower);
    const float normalizationTerm = (specularPower + 2) / 8.0;
    const vec3 specular = vec3(normalizationTerm * microfacetAttenuation);
    const vec3 diffuse = vec3(0.4) / PI;

    const vec3 fresnel =
        vec3(0.04) + (1.0 - vec3(0.04)) * pow(1.0 - clamp(dot(halfwayDirection, lightDirection), 0.0, 1.0), 5);
    const vec3 albedo = mix(diffuse, specular, fresnel);

    vec3 transmittanceToSun = sampleTransmittanceLUT_Ray(transmittance_LUT, atmosphere, surfacePosition, lightDirection);

    const vec3 luminance = transmittanceToSun * albedo * clamp(dot(surfaceNormal, lightDirection),0.0,1.0);
    const vec3 transmittance = sampleTransmittanceLUT_Segment(transmittance_LUT, atmosphere, origin, surfacePosition);

    return luminance * transmittance;
}

void main()
{
    const vec2 size = imageSize(image);
    const ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);
    if (texelCoord.x >= size.x || texelCoord.y >= size.y)
    {
        return;
    }

    const Camera camera = pc.cameraBuffer.cameras[pc.cameraIndex];
    const Atmosphere atmosphere = pc.atmosphereBuffer.atmospheres[pc.atmosphereIndex];

    // Convert from engine position (in meters with -y up) 
    // and the skyview coordinates (in megameters with +y up)
    vec3 position = camera.position.xyz / 1000000.0;
    position.y *= -1;
    position.y += atmosphere.planetRadiusMm;

    const vec2 clipSpaceUV = vec2((gl_GlobalInvocationID.xy / vec2(pc.drawExtent)) - 0.5) * 2.0;
    const float nearPlaneDepth = 1.0;
    const vec4 directionViewSpace = camera.inverseProjection * vec4(clipSpaceUV, nearPlaneDepth, 1.0);
    vec3 direction = normalize((camera.rotation * directionViewSpace).xyz);
    direction.y *= -1;

    const float radius = length(position);
    const float sin_horizonZenith = atmosphere.planetRadiusMm / radius;
    const float cos_horizonZenith = -safeSqrt(1.0 - sin_horizonZenith * sin_horizonZenith);

    vec3 sunIlluminanceToSkyLuminanceTransfer = vec3(0.0);
    
    // If sun is above horizon, the sun disk and sky is visible
    const float cos_directionZenith = dot(direction, position) / (length(direction) * length(position));
    if (cos_directionZenith < cos_horizonZenith)
    {   
        sunIlluminanceToSkyLuminanceTransfer += sampleGround(atmosphere, position, direction);
    }
    else
    {
        sunIlluminanceToSkyLuminanceTransfer += sampleMap_Direction(direction);
        sunIlluminanceToSkyLuminanceTransfer += sampleSunDisk(atmosphere, position, direction);
    }

    // ad-hoc tonemapping
    vec3 luminance = sunIlluminanceToSkyLuminanceTransfer * 10.0 * atmosphere.sunIntensitySpectrum;
    const vec3 color = pow(luminance, vec3(1.3));

    imageStore(image, texelCoord, vec4(color, 1.0));
}