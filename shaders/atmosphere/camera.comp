#version 460
#extension GL_EXT_buffer_reference2 : require
#extension GL_ARB_shading_language_include : require
#extension GL_EXT_nonuniform_qualifier : require

#include "../gbuffer/gbuffer.glinl"
#include "../gbuffer/pbr.glinl"
#include "../shadowmap.glinl"
#include "../types/camera.glsl"
#include "../types/atmosphere.glinl"
#include "../types/lights.glsl"

// This shader renders the ground and sky, while consuming a GBuffer to light opaque geometry with the sun

layout(local_size_x = 16, local_size_y = 16) in;

// Scene render target
layout(rgba16, set = 0, binding = 0) uniform image2D image;
layout(set = 0, binding = 1) uniform sampler2D fragmentDepth;

// Atmosphere LUTs
layout(set = 1, binding = 0) uniform sampler2D skyview_LUT;
layout(set = 1, binding = 1) uniform sampler2D transmittance_LUT;
layout(set = 1, binding = 2) uniform sampler2D multiscatter_LUT;

// Opaque geometry GBuffer

SZG_DECLARE_GBUFFER_SET(2)
#include "../gbuffer/gbufferFunctions.glinl"
#include "../gbuffer/pbrFunctions.glinl"

// Scattered directional lights' shadowmaps, just the sun for now
// TODO: use these shadow maps across all calculations that need to compute transmittance to a solar body
layout(set = 3, binding = 0) uniform sampler shadowMapSampler;
layout(set = 4, binding = 0) uniform texture2D shadowMaps[];

layout(buffer_reference, std430) readonly buffer AtmosphereBuffer
{
    Atmosphere atmospheres[];
};

layout(buffer_reference, std430) readonly buffer CameraBuffer
{
    Camera cameras[];
};

layout(buffer_reference, std430) readonly buffer LightDirectionalBuffer
{
    LightDirectional lights[16];
};

layout(push_constant) uniform PushConstant
{
    AtmosphereBuffer atmosphereBuffer;
    CameraBuffer cameraBuffer;

    uint atmosphereIndex;
    uint cameraIndex;

    uvec2 drawExtent;

    uint sunShadowMapIndex;
    uint padding0;

    uvec2 gbufferExtent;

    LightDirectionalBuffer directionalLights;
    uint atmosphereLightCount;
} pc;

LightDirectional getLight(uint index)
{
    return pc.directionalLights.lights[index];
}

#include "common.glinl"

#ifndef SZG_MULTISCATTERING_ENABLED
#define SZG_MULTISCATTERING_ENABLED 1
#endif

#include "raymarch.glinl"

vec3 sampleSkyViewLUT(const Atmosphere atmosphere, const vec3 position, const vec3 direction)
{
    // Horizon zenith cannot be less than PI/2, so we use sin and assume it is a quadrant 2 angle
    const float sinHorizonZenith = atmosphere.planetRadiusMm / length(position);
    const float horizonZenith = PI - asin(sinHorizonZenith);

    const float cosViewZenith = dot(position, direction) / (length(position) * length(direction));
    const float cosHorizonZenith = -safeSqrt(1.0 - sinHorizonZenith * sinHorizonZenith);

    const float viewZenith = acos(cosViewZenith);

    // We still want uv.y = 0 and uv.y = 1 to the extreme zenith angles
    // But since we make the horizon a straight line through the middle, and its zenith may not be PI/2,
    // we must scale angles differently depending on if they are above or below the horizon.

    float u, v;

    if (cosViewZenith > cosHorizonZenith)
    {
        // Above horizon, v shall range from 0.0 to 0.5
        // viewZenith varies from 0 to horizonZenith

        const float angleFraction = viewZenith / horizonZenith;

        // Increase angle density towards v = 0.5
        v = (1.0 - sqrt(1.0 - angleFraction)) * 0.5;
    }
    else
    {
        // Below horizon, v shall range from 0.5 to 1
        // viewZenith varies from horizonZenith to PI

        const float angleFraction = (viewZenith - horizonZenith) / (PI - horizonZenith);

        // Increase angle density towards v = 0.5
        v = sqrt(angleFraction) * 0.5 + 0.5;
    }

    {
        float azimuth = 0.0;

        if (direction.z == 0.0)
        {
            azimuth = sign(direction.x) * PI / 2.0;
        }
        else
        {
            azimuth = atan(direction.x, direction.z);
        }

        // azimuth varies -PI to PI

        u = (azimuth / (2.0 * PI)) + 0.5;
    }

    return texture(skyview_LUT, vec2(u, v)).rgb;
}

vec3 sampleSunDisk(const Atmosphere atmosphere, const LightDirectional celestialLight, const vec3 position, const vec3 direction)
{
    const vec3 directionToSun = -celestialLight.forward;

    const float cosDirectionSun = dot(direction, directionToSun) / (length(direction) * length(directionToSun));

    // Small angle approximation
    const float sinSunRadius = celestialLight.angularRadius;

    const float sinDirectionSun = safeSqrt(1.0 - cosDirectionSun * cosDirectionSun);

    const vec3 transmittanceToSun = sampleTransmittanceLUT_Ray(transmittance_LUT, atmosphere, position, direction);

    if (cosDirectionSun < 0.0)
    {
        return vec3(0.0);
    }

    return transmittanceToSun * (1.0 - smoothstep(0.2 * sinSunRadius, sinSunRadius, sinDirectionSun));
}

float computeFractionOfSunVisible(const Atmosphere atmosphere, const LightDirectional celestialLight, const vec3 position)
{
    const float sinHorizonZenith = atmosphere.planetRadiusMm / length(position);
    const float cosSunZenith = dot(-celestialLight.forward, normalize(position));

    // Ignore third dimension, since earth is a symmetrical sphere
    const vec2 directionToHorizon =
        normalize(vec2(sinHorizonZenith, safeSqrt(1.0 - sinHorizonZenith * sinHorizonZenith)));
    const vec2 directionToSun = normalize(vec2(safeSqrt(1.0 - cosSunZenith * cosSunZenith), cosSunZenith));

    const float cosHorizonSun = dot(directionToHorizon, directionToSun);

    // + when above horizon, - when below
    const float sinHorizonSun =
        sign(directionToSun.y - directionToHorizon.y) * safeSqrt(1.0 - cosHorizonSun * cosHorizonSun);

    // Small angle approximation
    const float sinSunRadius = celestialLight.angularRadius;

    if (sinHorizonSun > sinSunRadius)
    {
        return 1.0;
    }
    else if (sinHorizonSun < -sinSunRadius)
    {
        return 0.0;
    }

    // Approximation of the area of the chorded segment above the horizon divided by the area of the circle
    return 0.5 * (sinHorizonSun / sinSunRadius) + 0.5;
}

bool raycastHitTestPlanet(const Atmosphere atmosphere, const vec3 origin, const vec3 direction)
{
    float planet_t0, planet_t1;
    const bool hitPlanet =
        raySphereIntersection(origin, direction, atmosphere.planetRadiusMm, planet_t0, planet_t1) && planet_t0 > 0.0;

    return hitPlanet;
}

vec3 sampleEnvironmentLuminance(const Atmosphere atmosphere,
                                        const vec3 position,
                                        const vec3 direction)
{
    if (raycastTestSphere(position, direction, atmosphere.planetRadiusMm))
    {
        const bool includeGround = true;
        return computeLuminanceScatteringIntegral(
                   atmosphere, pc.atmosphereLightCount, transmittance_LUT, multiscatter_LUT, position, direction, includeGround)
            .luminance;
    }
    else
    {
        // If sun is above horizon, the sun disk and sky is visible.
        // We use the precomputed SkyView LUT to get this value.
        // The sky has low visual frequency, so it is more efficient to look up the values from a low resolution texture
        // than it is to raymarch for each pixel.

        vec3 luminance = sampleSkyViewLUT(atmosphere, position, direction);
        for(uint lightIndex = 0; lightIndex < pc.atmosphereLightCount; lightIndex++)
        {
            // TODO: sample shadow map per light
            const LightDirectional celestialLight = pc.directionalLights.lights[lightIndex];

            luminance += sampleSunDisk(atmosphere, celestialLight, position, direction) * celestialLight.color.rgb * celestialLight.strength;
        }

        return luminance;
    }
}

vec3 reflectDirection(const vec3 normal, const vec3 outgoingDirection)
{
    const vec3 parallel = dot(normal, outgoingDirection) * normal;
    return 2.0 * parallel - outgoingDirection;
}

vec3 sampleGeometryLuminance(const Atmosphere atmosphere,
                                      const vec3 origin,
                                      const vec3 direction,
                                      const PBRTexel material)
{
    // Alternative way to compute surface position
    // const vec4 positionViewSpace = camera.inverseProjection * vec4(clipSpaceUV, sceneDepth, 1.0);
    // distanceToGround = length(positionViewSpace) / 1000000.0;
    // const vec3 surfacePosition = position + distanceToGround * direction;

    const vec3 surfacePosition = material.position / METERS_PER_MM + atmosphere.planetRadiusMm * WORLD_UP;

    const vec3 transmittanceToSurface =
        sampleTransmittanceLUT_Segment(transmittance_LUT, atmosphere, origin, surfacePosition);

    vec3 surfaceLuminance = vec3(0.0);

    // Ad-hoc environment reflection, picks up metallic reflection and ambient lighting on dialectrics
    // const vec3 transmittanceToSurface =
    //     sampleTransmittanceLUT_Segment(transmittance_LUT, atmosphere, position, surfacePosition);
    const vec3 reflectionDirection = reflectDirection(material.normal, -direction);
    const vec3 fresnelReflection = computeFresnel(material, -direction, reflectionDirection);

    const vec3 metallicReflectionLuminance = transmittanceToSurface
                                    * sampleEnvironmentLuminance(atmosphere, surfacePosition, reflectionDirection);
    // Diffuse reflection/ambient lighting is added later, per light
    surfaceLuminance += material.occlusion * material.metallic * metallicReflectionLuminance * fresnelReflection;

    for(uint lightIndex = 0; lightIndex < pc.atmosphereLightCount; lightIndex++)
    {
        const LightDirectional celestialLight = getLight(lightIndex);

        const vec3 lightDirection = normalize(-celestialLight.forward);
        const vec3 viewDirection = normalize(-direction);

        const vec3 diffuseContribution = diffuseBRDF(material, lightDirection);
        const vec3 specularContribution = specularBRDF(material, lightDirection, viewDirection);

        const vec3 fresnel = computeFresnel(material, lightDirection, viewDirection);

        const vec3 transmittanceToLight =
            sampleTransmittanceLUT_Ray(transmittance_LUT, atmosphere, surfacePosition, lightDirection);

        const float fractionOfDiskVisible = computeFractionOfSunVisible(atmosphere, celestialLight, surfacePosition);

        const vec4 shadowCoord = TO_TEX_COORD_MAT * celestialLight.projection * celestialLight.view * vec4(material.position, 1.0);
        const float shadowFactor = sampleShadowMap(shadowMaps[lightIndex], shadowMapSampler, shadowCoord);

        surfaceLuminance += shadowFactor * fractionOfDiskVisible * transmittanceToLight * transmittanceToSurface
                                   * material.occlusion * mix(diffuseContribution, specularContribution, fresnel)
                                   * clamp(dot(material.normal, lightDirection), 0.0, 1.0) * celestialLight.color.rgb * celestialLight.strength;
   
        // TODO: fresnel weighted ambient lighting to pick up subscattered light? 
        // Does it significantly contribute to the appearance of ambient lighting?
        // TODO: one multiscatter LUT for each light
        const vec3 diffuseAmbientLuminance =
            transmittanceToSurface
            * sampleMultiscatterLUT(multiscatter_LUT, atmosphere, surfacePosition, celestialLight.forward)
            * material.subscatteringColor / PI;

        surfaceLuminance += material.occlusion * diffuseAmbientLuminance * (1.0 - material.metallic) * celestialLight.color.rgb * celestialLight.strength;
    }

    {
        const bool includeGround = false;
        const float sampleDistance = length(surfacePosition - origin);
        const vec3 aerialPerspectiveLuminance =
            computeLuminanceScatteringIntegral(
                atmosphere, pc.atmosphereLightCount, transmittance_LUT, multiscatter_LUT, origin, direction, includeGround, sampleDistance)
                .luminance;

        surfaceLuminance += aerialPerspectiveLuminance;
    }

    return surfaceLuminance;
}

void main()
{
    const vec2 size = imageSize(image);
    const ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);
    if (texelCoord.x >= size.x || texelCoord.y >= size.y)
    {
        return;
    }

    const Camera camera = pc.cameraBuffer.cameras[pc.cameraIndex];
    const Atmosphere atmosphere = pc.atmosphereBuffer.atmospheres[pc.atmosphereIndex];

    const vec2 uvFull = (vec2(texelCoord) + vec2(0.5, 0.5)) / size;
    const float sceneDepth = texture(fragmentDepth, uvFull).r;

    vec3 position = camera.position.xyz / METERS_PER_MM + atmosphere.planetRadiusMm * WORLD_UP;

    const vec2 uvClipSpace = vec2((gl_GlobalInvocationID.xy / vec2(pc.drawExtent)) - 0.5) * 2.0;
    const float nearPlaneDepth = 1.0;
    const vec4 directionViewSpace = camera.inverseProjection * vec4(uvClipSpace, nearPlaneDepth, 1.0);
    vec3 direction = normalize((camera.rotation * directionViewSpace).xyz);

    vec3 luminance = vec3(0.0);

    // Luminance NOT from the sun and should NOT be multiplied by sun intensity
    vec3 surfaceLuminance = vec3(0.0);

    // GBuffer size should in general match the size of the image
    const vec2 uvGBuffer = (vec2(texelCoord) + vec2(0.5, 0.5)) / vec2(pc.gbufferExtent);
    const PBRTexel material = convertPBRProperties(sampleGBuffer(uvGBuffer));

    if (sceneDepth == 0.0 || material.position.y > 0.0)
    {
        // Unobscured view of the virtual environment, i.e. sky or ground

        luminance += sampleEnvironmentLuminance(atmosphere, position, direction);
    }
    else // sceneDepth > 0.0 && material.position.y < 0.0
    {
        surfaceLuminance = imageLoad(image, texelCoord).rgb;

        luminance += sampleGeometryLuminance(atmosphere, position, direction, material);
    }

    // ad-hoc tonemapping
    const vec3 color = pow(luminance * 10.0 + surfaceLuminance, vec3(1.2));

    imageStore(image, texelCoord, vec4(color, 1.0));
}