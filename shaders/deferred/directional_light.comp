#version 460
#extension GL_EXT_buffer_reference2 : require
#extension GL_ARB_shading_language_include : require

#include "../types/camera.glsl"
#include "../types/atmosphere.glsl"

layout (local_size_x = 16, local_size_y = 16) in;
layout(rgba16f,set = 0, binding = 0) uniform image2D image;

layout(set = 1, binding = 0) uniform sampler2D samplerDiffuse;
layout(set = 1, binding = 1) uniform sampler2D samplerSpecular;
layout(set = 1, binding = 2) uniform sampler2D samplerNormal;
layout(set = 1, binding = 3) uniform sampler2D samplerWorldPosition;

layout(set = 2, binding = 0) uniform sampler2D shadowMap;

layout(buffer_reference, std430) readonly buffer CameraBuffer{
	Camera cameras[];
};

layout(buffer_reference, std430) readonly buffer AtmosphereBuffer{
	Atmosphere atmospheres[];
};

layout (push_constant) uniform PushConstant
{
	CameraBuffer cameraBuffer;
	AtmosphereBuffer atmosphereBuffer;
	uint atmosphereIndex;
	uint cameraIndex;
	uint cameraDirectionalLightIndex;
} pushConstant;

/*
* Shadow mapping methodology adapted from 
* https://github.com/SaschaWillems/Vulkan/blob/master/shaders/glsl/shadowmapping/scene.frag
*/
float sampleShadowMap(vec4 shadowCoord)
{
	if ( shadowCoord.z > 0.0 && shadowCoord.z < 1.0 ) 
	{
		float dist = texture( shadowMap, shadowCoord.st ).r;
		if ( shadowCoord.w > 0.0 && dist > shadowCoord.z ) 
		{
			return 0.0;
		}
	}
	return 1.0;
}

// shift X and Y
// from clip space/ndc (-1,-1) to (1,1)
// to texture coordinates (0,0) to (1,1) 
const mat4 toTexCoordMat = mat4(
	0.5, 0.0, 0.0, 0.0,
	0.0, 0.5, 0.0, 0.0,
	0.0, 0.0, 1.0, 0.0,
	0.5, 0.5, 0.0, 1.0
);

/*
* Blinn-phong shader, based on:
* James F. Blinn. 1977. "Models of light reflection for computer synthesized pictures."
*/
void main()
{
	const vec2 size = imageSize(image);
    const ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);
    if(texelCoord.x >= size.x || texelCoord.y >= size.y)
	{
		return;
	}
	const vec2 uv = vec2(gl_GlobalInvocationID.xy / size);


	const Camera camera = pushConstant.cameraBuffer.cameras[pushConstant.cameraIndex];

	const Camera directionalLight = pushConstant.cameraBuffer.cameras[pushConstant.cameraDirectionalLightIndex];
	const vec3 lightDirection = -directionalLight.forwardWorld.xyz;
	const vec3 normal = texture(samplerNormal,uv).xyz;
	const float lambertian = max(dot(lightDirection, normal), 0.0);

	const vec3 position = texture(samplerWorldPosition,uv).xyz;
	const vec3 viewDirection = normalize(camera.position - position);
	// Blinn noted that reflected light is less likely to be intercepted by randomly distributed surface facets
	// when the angle of reflection is as small as possible.
	const vec3 halfwayDirection = normalize(lightDirection + viewDirection);
	// specularCosine is a measure of the probability that these surface imperfection facets are oriented
	// with the normal, which would maximize the light reflected.
	const float specularCosine = clamp(dot(halfwayDirection, normal), 0.0,1.0);

	// Higher shininess means speculars peak faster and are smaller
	const float shininess = 16.0;

	// This arbitrary fade factor smoothes out cases where the view vector is near 90 degrees from the normal.
	// This avoids a specular highlight snapping in, which seems to be an issue with parallel rays.
	// TODO: investigate how to better handle directional lighting with this shader
	const float fade = smoothstep(0.0,0.01,lambertian);

	// Phong facet distribution function. 
	const float specular = fade * pow(specularCosine, shininess);

	const Atmosphere atmosphere = pushConstant.atmosphereBuffer.atmospheres[pushConstant.atmosphereIndex];

	const vec3 diffuseColor = texture(samplerDiffuse,uv).rgb;
	const vec3 specularColor = texture(samplerSpecular,uv).rgb;

	const vec3 ambientContribution = diffuseColor * atmosphere.ambientColor;
	const vec3 diffuseContribution = lambertian * diffuseColor * atmosphere.sunlightColor;
	const vec3 specularContribution = specular * specularColor * atmosphere.sunlightColor;
		
	const vec4 shadowCoord = (toTexCoordMat * directionalLight.projection * directionalLight.view) * vec4(position, 1.0);
	const float attenuationShadow = sampleShadowMap(shadowCoord);

	const vec4 finalColor = vec4(
		ambientContribution 
		+ attenuationShadow * (diffuseContribution + specularContribution)
		, 1.0
	);

	imageStore(image, texelCoord, finalColor);
}