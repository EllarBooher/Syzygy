#version 460
#extension GL_EXT_buffer_reference2 : require
#extension GL_ARB_shading_language_include : require

/*
* Deferred Blinn-phong shading consuming a GBuffer with a single light/shadowmap
*/

#include "../types/camera.glsl"
#include "../types/atmosphere.glsl"

layout (local_size_x = 16, local_size_y = 16) in;
layout(rgba16f,set = 0, binding = 0) uniform image2D image;

layout(set = 1, binding = 0) uniform sampler2D samplerDiffuse;
layout(set = 1, binding = 1) uniform sampler2D samplerSpecular;
layout(set = 1, binding = 2) uniform sampler2D samplerNormal;
layout(set = 1, binding = 3) uniform sampler2D samplerWorldPosition;

layout(set = 2, binding = 0) uniform sampler2D shadowMap;

layout(buffer_reference, std430) readonly buffer CameraBuffer{
	Camera cameras[];
};

layout(buffer_reference, std430) readonly buffer AtmosphereBuffer{
	Atmosphere atmospheres[];
};

layout (push_constant) uniform PushConstant
{
	CameraBuffer cameraBuffer;
	AtmosphereBuffer atmosphereBuffer;
	uint atmosphereIndex;
	uint cameraIndex;
	uint cameraDirectionalLightIndex;
} pushConstant;

float sampleShadowMap(vec4 shadowCoord)
{
	float dist = texture(shadowMap, shadowCoord.st).r;
	if (dist > shadowCoord.z && dist > 0.0) 
	{
		return 0.0;
	}

	return 1.0;
}

const mat4 toTexCoordMat = mat4(
	0.5, 0.0, 0.0, 0.0,
	0.0, 0.5, 0.0, 0.0,
	0.0, 0.0, 1.0, 0.0,
	0.5, 0.5, 0.0, 1.0
);

void main()
{
	const vec2 size = imageSize(image);
    const ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);
    if(texelCoord.x >= size.x || texelCoord.y >= size.y)
	{
		return;
	}

	// The uv needs to be offset to avoid floating point errors on texel boundaries
	const vec2 offset = vec2(0.5,0.5);
	const vec2 uv = (vec2(gl_GlobalInvocationID.xy) + offset) / size;

	const vec4 diffuse = texture(samplerDiffuse,uv).rgba;

	// No transparent geometry for now, less than 1.0 alpha indicates background texels
	if (diffuse.a < 1.0)
	{
		return;
	}

	const Camera directionalLight = pushConstant.cameraBuffer.cameras[pushConstant.cameraDirectionalLightIndex];
	
	const vec3 lightDirection = normalize(-directionalLight.forwardWorld.xyz);
	const vec3 normal = normalize(texture(samplerNormal,uv).xyz);
	const float lambertian = max(dot(lightDirection, normal), 0.0);

	const vec3 position = texture(samplerWorldPosition,uv).xyz;

	const Atmosphere atmosphere = pushConstant.atmosphereBuffer.atmospheres[pushConstant.atmosphereIndex];
	const vec3 diffuseColor = diffuse.rgb;
	
	// AMBIENT
	const vec3 ambientContribution = diffuseColor * atmosphere.ambientColor;

	// DIFFUSE
	const vec3 diffuseContribution = lambertian * diffuseColor * atmosphere.sunlightColor;

	// SPECULAR 
	const Camera camera = pushConstant.cameraBuffer.cameras[pushConstant.cameraIndex];

	const vec3 viewDirection = normalize(camera.position.xyz - position);
	const vec3 halfwayDirection = normalize(lightDirection + viewDirection);
	const float specularCosine = clamp(dot(halfwayDirection, normal), 0.0,1.0);

	const float shininess = 16.0;
	const float fade = smoothstep(0.0,0.01,lambertian);
	const float specular = fade * pow(specularCosine, shininess);
	const vec3 specularColor = texture(samplerSpecular,uv).rgb;
	const vec3 specularContribution = specular * specularColor * atmosphere.sunlightColor;
		
	// SHADOW
	const mat4 shadowMatrix = toTexCoordMat * directionalLight.projection * directionalLight.view;
	const vec4 shadowCoord = shadowMatrix * vec4(position, 1.0);
	const float attenuationShadow = sampleShadowMap(shadowCoord); 

	const vec4 finalColor = vec4(
		ambientContribution 
		+ attenuationShadow * (diffuseContribution + specularContribution)
		, 1.0
	);
	
	imageStore(image, texelCoord, finalColor);
}